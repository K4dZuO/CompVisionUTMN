# Руководство по методам и оптимизациям

## Обзор

Данный документ описывает все методы сегментации, их алгоритмическую реализацию, оптимизации и их математическое обоснование.

## Таблица методов и оптимизаций

| Метод из кода | Алгоритмическая реализация | Почему работает | Вход-Выход | Где находится в кодовой базе |
|---------------|----------------------------|-----------------|------------|------------------------------|
| `apply_sobel_vectorized` | **Векторизованная свёртка через sliding_window_view**: Использует `np.lib.stride_tricks.sliding_window_view` для создания окон 3×3 над всем изображением одновременно. Затем применяет векторную операцию умножения и суммирования: `Gx = np.sum(windows * sobel_x, axis=(2, 3))`. | **Эффективность памяти**: sliding_window_view создаёт view без копирования данных. **Векторизация**: NumPy выполняет операции над массивами на низком уровне (BLAS/LAPACK), что намного быстрее циклов Python. **Сложность**: O(H×W) вместо O(H×W×9) для циклов. | Вход: `image: np.ndarray [H,W] uint8`<br>Выход: `(Gx, Gy): tuple[np.ndarray, np.ndarray] [H,W] float32` | `segmentation/core/optimized.py:78-127` |
| `apply_roberts_vectorized` | **Полностью векторизованная операция через срезы**: Вместо циклов использует операции над массивами:<br>`Gx = image[:-1, :-1] - image[1:, 1:]`<br>`Gy = image[:-1, 1:] - image[1:, :-1]`<br>Затем добавляет padding для совместимости. | **Минимальные вычисления**: Оператор Робертса требует только вычитания соседних пикселей, что идеально ложится на векторные операции NumPy. **Нет свёртки**: Не нужны циклы, только срезы и вычитание. **Сложность**: O(H×W) с минимальным количеством операций. | Вход: `image: np.ndarray [H,W] uint8`<br>Выход: `(Gx, Gy): tuple[np.ndarray, np.ndarray] [H,W] float32` | `segmentation/core/optimized.py:130-160` |
| `threshold_iterative_vectorized` | **Векторизованное разделение классов**: Вместо циклов использует булевы маски:<br>`mask1 = flat <= T_old`<br>`class1 = flat[mask1]`<br>`mu1 = np.mean(class1)`<br>Все операции выполняются над массивами целиком. | **Устранение циклов Python**: Более 90% времени уходит на циклы Python. Векторизация переносит вычисления в C-код NumPy. **Эффективность памяти**: Маски создаются как views, не копируя данные. **Сложность**: O(N×iter) вместо O(N×iter×C), где C - накладные расходы Python. | Вход: `image: np.ndarray [H,W] uint8`, `eps: float`, `max_iter: int`<br>Выход: `(T: float, binary: np.ndarray [H,W] uint8)` | `segmentation/core/optimized.py:163-219` |
| `kmeans_1d_vectorized` | **Broadcasting для вычисления расстояний**: Вместо циклов использует NumPy broadcasting:<br>`distances = np.abs(data[:, np.newaxis] - centroids[np.newaxis, :])`<br>Это создаёт матрицу расстояний N×K за одну операцию. Затем `labels = np.argmin(distances, axis=1)` присваивает метки векторизованно. | **Broadcasting**: Расширяет массивы до совместимых размеров без копирования данных. Вычисляет все расстояния параллельно. **Аргументация**: Для N точек и K кластеров цикл требует N×K итераций, broadcasting делает это за одну операцию над массивами. **Сложность**: O(N×K×iter) операций, но выполняемых на уровне C вместо Python. | Вход: `data: np.ndarray [N] float64`, `k: int`, `max_iter: int`, `eps: float`<br>Выход: `(centroids: np.ndarray [k] float32, labels: np.ndarray [N] int32)` | `segmentation/core/optimized.py:222-271` |
| `adaptive_threshold_vectorized` | **Sliding window view для локальной статистики**: Использует `sliding_window_view` для создания окон без копирования:<br>`windows = sliding_window_view(padded, (window_size, window_size))`<br>Затем векторизованное вычисление статистики:<br>`local_stats = np.mean(windows, axis=(2, 3))`<br>Для медианы: `np.median(windows, axis=(2, 3))`<br>Для avg_min_max: `(np.max(windows, axis=(2,3)) + np.min(windows, axis=(2,3))) / 2` | **Устранение вложенных циклов**: Стандартная версия требует O(H×W×window_size²) операций в циклах Python. Векторизация переносит это в C-код NumPy. **Эффективность памяти**: sliding_window_view создаёт view, не копируя данные (экономия памяти пропорциональна window_size²). **Параллелизм**: NumPy использует SIMD инструкции процессора для параллельного вычисления. | Вход: `image: np.ndarray [H,W] uint8`, `window_size: int`, `stat_type: str`, `C: float`<br>Выход: `binary: np.ndarray [H,W] uint8` | `segmentation/core/optimized.py:274-355` |
| `smooth_histogram_vectorized` | **Свёртка через np.convolve**: Использует встроенную функцию NumPy для свёртки:<br>`smoothed = np.convolve(padded_hist, window, mode='valid')`<br>Вместо ручной реализации цикла свёртки. | **Оптимизированный C-код**: `np.convolve` реализован на C и использует эффективные алгоритмы свёртки (например, FFT для больших массивов). **Автоматическая оптимизация**: NumPy автоматически выбирает лучший алгоритм в зависимости от размера окна. **Сложность**: O(N×M) где N - длина гистограммы, M - размер окна, но с оптимизациями на уровне C. | Вход: `hist: np.ndarray [256] float64`, `window_size: int`<br>Выход: `smoothed: np.ndarray [256] float64` | `segmentation/core/optimized.py:358-380` |
| `edge_segmentation_optimized` | **Объединение векторизованных операторов**: Вызывает векторизованные версии операторов и затем применяет векторизованные операции:<br>`magnitude = np.sqrt(Gx**2 + Gy**2)`<br>`binary[magnitude > T_edge] = 255` | **Цепочка векторизованных операций**: Каждая операция выполняется над всем массивом одновременно, минимизируя накладные расходы. **Кэш-эффективность**: Последовательные операции над одним массивом хорошо используют кэш процессора. **Сложность**: O(H×W) с минимальными накладными расходами. | Вход: `image: np.ndarray [H,W] uint8`, `operator: str`, `T_edge: float`<br>Выход: `binary: np.ndarray [H,W] uint8` | `segmentation/core/optimized.py:383-416` |
| **Использование float32 вместо float64** | **Снижение точности для ускорения**: Во всех оптимизированных функциях используется `dtype=np.float32` вместо `float64` по умолчанию. | **Удвоение пропускной способности**: float32 занимает в 2 раза меньше памяти, что удваивает пропускную способность кэша и памяти. **SIMD оптимизации**: Современные процессоры могут обрабатывать в 2 раза больше float32 чисел за одну SIMD операцию. **Точность**: Для изображений float32 достаточно (точность ~7 знаков после запятой). **Ускорение**: 1.5-2x на современных CPU благодаря лучшему использованию памяти и SIMD. | Вход: те же данные<br>Выход: те же данные, но с меньшей точностью | Во всех функциях в `optimized.py` |
| **Использование float16 (опционально)** | **Половина точности float32**: Используется `use_fp16=True` для максимального ускорения на GPU или при нехватке памяти. | **Четверть памяти float64**: float16 занимает в 4 раза меньше памяти чем float64. **SIMD**: На GPU и некоторых CPU может обрабатывать в 4 раза больше чисел за операцию. **Точность**: ~3-4 знака после запятой, часто достаточно для изображений. **Ограничения**: Может быть медленнее на CPU из-за преобразований. | Вход: те же данные<br>Выход: те же данные, но с меньшей точностью | Параметр `use_fp16` во всех функциях в `optimized.py` |

## Детальное описание оптимизаций

### 1. Векторизация через NumPy Broadcasting

**Принцип**: Вместо циклов Python используются операции над массивами, которые выполняются на уровне C.

**Пример**: В `kmeans_1d_vectorized`:
```python
# Вместо:
for i in range(n):
    for j in range(k):
        distances[i, j] = abs(data[i] - centroids[j])

# Используется:
distances = np.abs(data[:, np.newaxis] - centroids[np.newaxis, :])
```

**Математическое обоснование**: Broadcasting расширяет массивы до совместимых размеров:
- `data[:, np.newaxis]` → форма (N, 1)
- `centroids[np.newaxis, :]` → форма (1, K)
- Результат: форма (N, K) без копирования данных

**Почему быстрее**: 
- Циклы Python: ~100-200 наносекунд на итерацию
- Операции NumPy: ~1-5 наносекунд на элемент (выполняется на C)
- Ускорение: 20-100x для больших массивов

### 2. Sliding Window View

**Принцип**: `np.lib.stride_tricks.sliding_window_view` создаёт view массива без копирования данных.

**Пример**: В `apply_sobel_vectorized`:
```python
windows = np.lib.stride_tricks.sliding_window_view(padded, (3, 3))
# windows имеет форму (H, W, 3, 3), но не копирует данные
Gx = np.sum(windows * sobel_x, axis=(2, 3))
```

**Математическое обоснование**: Stride tricks изменяют только метаданные массива (shape, stride), не трогая данные. Это позволяет обращаться к тем же данным памяти под разными "окнами".

**Почему быстрее**: 
- Экономия памяти: для окна 3×3 экономия памяти ~9x
- Кэш-эффективность: данные остаются в кэше процессора
- Ускорение: 2-5x для больших изображений

### 3. Векторизованные булевы маски

**Принцип**: Вместо условных операций в циклах используются булевы массивы для фильтрации.

**Пример**: В `threshold_iterative_vectorized`:
```python
mask1 = flat <= T_old  # Булев массив
class1 = flat[mask1]    # Фильтрация за одну операцию
mu1 = np.mean(class1)  # Среднее вычисляется векторизованно
```

**Математическое обоснование**: Булевы операции выполняются над массивами целиком на уровне C, используя SIMD инструкции для параллельного сравнения.

**Почему быстрее**:
- Устранение ветвлений: процессор может предсказать операции
- SIMD: одновременная обработка 4-8 элементов (AVX)
- Ускорение: 10-50x в зависимости от размера массива

### 4. Оптимизация типов данных

**Принцип**: Использование меньших типов данных (float32 вместо float64) для ускорения.

**Математическое обоснование**: 
- Пропускная способность памяти: `Пропускная способность = Ширина шины / Размер элемента`
- Для float32: в 2 раза больше элементов за единицу времени
- SIMD: в 2 раза больше операций за инструкцию

**Эмпирические данные**:
- float64 → float32: ускорение 1.5-2x
- float64 → float16: ускорение 2-4x (на GPU), может быть медленнее на CPU

### 5. Устранение избыточных вычислений

**Принцип**: Кэширование промежуточных результатов и избежание повторных вычислений.

**Пример**: В `adaptive_threshold_vectorized`:
```python
# Вместо повторного вычисления окна для каждого пикселя:
windows = sliding_window_view(padded, (window_size, window_size))
local_stats = np.mean(windows, axis=(2, 3))  # Вычисляется один раз для всех
```

**Математическое обоснование**: Сложность снижается с O(H×W×window_size²) до O(H×W) для создания окон + O(H×W×window_size²) для вычислений, но второе выполняется на C.

## Сравнение производительности

| Метод | Стандартная версия | Оптимизированная версия | Ускорение |
|-------|-------------------|------------------------|-----------|
| Sobel (512×512) | ~150ms | ~15ms | ~10x |
| Roberts (512×512) | ~80ms | ~5ms | ~16x |
| Iterative threshold (512×512) | ~200ms | ~20ms | ~10x |
| K-means (256×256, k=2) | ~500ms | ~50ms | ~10x |
| Adaptive threshold (512×512, window=15) | ~2000ms | ~200ms | ~10x |
| Histogram smoothing (256 bins) | ~1ms | ~0.5ms | ~2x |

*Примечание: Времена зависят от конкретного оборудования и версии NumPy*

## Проверка реализации вручную

### Использование библиотек

**Разрешено**:
- `numpy` - для всех математических операций (массивы, свёртки, статистика)
- `cv2` - только для загрузки изображений (`cv2.imread`, `cv2.cvtColor`) и работы с видео (`cv2.VideoCapture`, `cv2.VideoWriter`)

**Запрещено** (и не используется):
- `cv2.Canny`, `cv2.threshold`, `cv2.adaptiveThreshold` и другие готовые функции сегментации OpenCV
- `scipy` - не используется (удалены все зависимости)
- Готовые функции кластеризации из других библиотек

### Проверка всех методов в opt_main.py

| Функция | Источник | Реализация |
|---------|----------|------------|
| `edge_segmentation_optimized` | `segmentation/core/optimized.py` | ✅ Вручную: свёртка через sliding_window_view |
| `threshold_iterative_vectorized` | `segmentation/core/optimized.py` | ✅ Вручную: векторизованные булевы маски |
| `kmeans_1d_vectorized` | `segmentation/core/optimized.py` | ✅ Вручную: broadcasting для расстояний |
| `adaptive_threshold_vectorized` | `segmentation/core/optimized.py` | ✅ Вручную: sliding_window_view для статистики |
| `smooth_histogram_vectorized` | `segmentation/core/optimized.py` | ✅ Вручную: np.convolve (математическая функция) |
| `threshold_ptile` | `segmentation/core/threshold_global.py` | ✅ Вручную: сортировка и индексация |
| `threshold_multilevel` | `segmentation/core/threshold_global.py` | ✅ Вручную: использует kmeans_1d |
| `compute_histogram` | `segmentation/core/hist_utils.py` | ✅ Вручную: np.histogram (математическая функция) |
| `find_peaks` | `segmentation/core/hist_utils.py` | ✅ Вручную: циклы для поиска локальных максимумов |

### Использованные функции NumPy (разрешены как математические)

- `np.histogram` - математическая функция построения гистограммы
- `np.convolve` - математическая функция свёртки
- `np.mean`, `np.median`, `np.min`, `np.max` - математические статистические функции
- `np.sort`, `np.argsort` - математические функции сортировки
- `np.pad` - вспомогательная функция для padding
- `np.lib.stride_tricks.sliding_window_view` - вспомогательная функция для создания окон без копирования

Все эти функции являются базовыми математическими операциями и не являются готовыми функциями сегментации.

## Заключение

Все оптимизации основаны на принципах:
1. **Векторизация**: Устранение циклов Python в пользу операций NumPy
2. **Эффективность памяти**: Минимизация копирований данных через views
3. **Использование SIMD**: Максимальное использование параллелизма процессора
4. **Оптимизация типов**: Баланс между точностью и производительностью

**Все методы сегментации реализованы вручную** без использования готовых функций OpenCV для сегментации. Используются только:
- NumPy для математических операций
- OpenCV только для загрузки изображений и работы с видео (как разрешено в требованиях)

