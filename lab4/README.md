# Сегментация изображений

Приложение для классической сегментации изображений с графическим интерфейсом.

## Описание

Реализация классических алгоритмов сегментации изображений без использования готовых CV-функций, используя только numpy для математики. Приложение включает:

1. **Сегментация по краям** — операторы Собеля, Превитта и Робертса
2. **Глобальная пороговая сегментация**:
   - Метод площади (P-tile)
   - Метод последовательных приближений
   - Метод K-средних
   - Многоуровневая сегментация
   - Сглаживание гистограммы и поиск пиков
3. **Адаптивная пороговая сегментация** — с различными типами статистики

## Установка

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Запустите приложение:
```bash
python main.py
```

## Использование

1. **Загрузка изображения**: Нажмите кнопку "Загрузить изображение" и выберите файл
2. **Выбор метода сегментации**: Переключитесь на нужную вкладку (Края, Глобальные пороги, Адаптивные пороги)
3. **Настройка параметров**: Измените параметры метода через элементы управления
4. **Применение**: Нажмите кнопку "Применить" для выполнения сегментации

### Сегментация по краям

- Выберите оператор (Собель, Превитт, Робертс)
- Установите порог градиента T_edge
- Результат показывается в бинарном виде (0 и 255)

### Глобальная пороговая сегментация

- **P-tile**: Установите процент пикселей P, которые должны быть выше порога
- **Последовательные приближения**: Установите точность eps для критерия останова
- **K-средних**: Выберите количество кластеров k
- **Гистограмма**: 
  - Включите сглаживание для уменьшения шума
  - Покажите пики на гистограмме для визуального анализа

### Адаптивная пороговая сегментация

- Выберите тип статистики (mean, median, avg_min_max)
- Установите размер окна (нечётное число)
- Настройте корректирующий параметр C

## Структура проекта

```
segmentation/
├── core/
│   ├── edges.py              # Операторы градиента
│   ├── threshold_global.py   # Глобальные пороги
│   ├── threshold_adaptive.py # Адаптивные пороги
│   └── hist_utils.py         # Гистограммы и сглаживание
├── visual/
│   └── display.py            # Функции визуализации
└── main.py                   # GUI приложение
```

## Требования

- Python 3.7+
- numpy >= 1.21.0
- PySide6 >= 6.0.0
- opencv-python >= 4.5.0
- matplotlib >= 3.5.0

## Особенности

- Все алгоритмы реализованы вручную с использованием только numpy
- Математически прозрачные алгоритмы без чёрных ящиков
- Интерактивный GUI с возможностью изменения параметров в реальном времени
- Визуализация исходного изображения, гистограммы и результатов
- Сравнение различных методов на одном экране
- Оптимизированные версии функций с векторными операциями и FFT

## Математическое описание алгоритмов

### 1. Сегментация по краям

#### Оператор Собеля

Вычисляет градиенты изображения через свёртку с ядрами:

**Градиент по X:**
```
Gx = I * Kx, где Kx = [-1  0  1]
                     [-2  0  2]
                     [-1  0  1]
```

**Градиент по Y:**
```
Gy = I * Ky, где Ky = [-1 -2 -1]
                     [ 0  0  0]
                     [ 1  2  1]
```

**Модуль градиента:**
```
|G| = √(Gx² + Gy²)
```

**Направление градиента:**
```
θ = arctan2(Gy, Gx)
```

**Бинаризация:**
```
B(x,y) = { 255, если |G(x,y)| > T_edge
         { 0,   иначе
```

#### Оператор Превитта

Аналогичен Собелю, но с другими весами:
```
Kx = [-1  0  1]    Ky = [-1 -1 -1]
     [-1  0  1]         [ 0  0  0]
     [-1  0  1]         [ 1  1  1]
```

#### Оператор Робертса

Использует перекрёстные градиенты 2×2:
```
Gx[i,j] = I[i,j] - I[i+1,j+1]
Gy[i,j] = I[i,j+1] - I[i+1,j]
```

### 2. Глобальная пороговая сегментация

#### Метод P-tile

Находит порог T такой, что заданный процент P пикселей имеет яркость выше порога:

```
T = argmin_t { |P - (количество пикселей с яркостью > t) / N| }
```

где N - общее количество пикселей.

#### Метод последовательных приближений

Итеративный алгоритм:

1. **Инициализация:** T₀ = (min(I) + max(I)) / 2

2. **Итерация:**
   - Разделение: C₁ = {I(x,y) | I(x,y) ≤ Tₖ}, C₂ = {I(x,y) | I(x,y) > Tₖ}
   - Вычисление средних: μ₁ = mean(C₁), μ₂ = mean(C₂)
   - Обновление: Tₖ₊₁ = (μ₁ + μ₂) / 2

3. **Останов:** |Tₖ₊₁ - Tₖ| < ε

#### Метод K-средних

1D-кластеризация значений яркости:

1. **Инициализация:** k центроидов c₁, c₂, ..., cₖ равномерно распределены

2. **Итерация:**
   - Присваивание: label(x,y) = argminᵢ |I(x,y) - cᵢ|
   - Обновление: cᵢ = mean({I(x,y) | label(x,y) = i})

3. **Порог:** T = (cᵢ + cᵢ₊₁) / 2 для соседних кластеров

### 3. Адаптивная пороговая сегментация

Для каждого пикселя (x,y) вычисляется локальный порог в окне W×W:

**Среднее:**
```
T(x,y) = mean(I[x-w/2:x+w/2, y-w/2:y+w/2]) - C
```

**Медиана:**
```
T(x,y) = median(I[x-w/2:x+w/2, y-w/2:y+w/2]) - C
```

**Среднее минимума и максимума:**
```
T(x,y) = (min(I[x-w/2:x+w/2, y-w/2:y+w/2]) + 
          max(I[x-w/2:x+w/2, y-w/2:y+w/2])) / 2 - C
```

**Бинаризация:**
```
B(x,y) = { 255, если I(x,y) > T(x,y)
         { 0,   иначе
```

### 4. Гистограмма и сглаживание

**Гистограмма:**
```
H[i] = количество пикселей с яркостью i, i ∈ [0, 255]
```

**Сглаживание (свёртка с равномерным окном):**
```
H_smooth[i] = (1/w) * Σⱼ H[i+j], j ∈ [-w/2, w/2]
```

**Поиск пиков:**
Пик - это локальный максимум, где:
- H[i] > threshold
- H[i] > H[i±d] для всех d < min_distance

## Оптимизированные версии

Проект включает оптимизированные версии функций в модуле `segmentation.core.optimized`:

- **Векторные операции:** Использование numpy broadcasting и матричных операций
- **FFT-свёртки:** Быстрое преобразование Фурье для свёрток больших ядер
- **Сепарабельные ядра:** Разложение 2D-свёртки на две 1D-свёртки для операторов Собеля/Превитта
- **FP16 поддержка:** Использование float16 где возможно для экономии памяти

