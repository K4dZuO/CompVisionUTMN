# Система анализа оптического потока для видео с трафиком

## Описание

Приложение для анализа оптического потока в видеопоследовательностях с использованием алгоритмов Хорна-Шанка и Лукаса-Канаде. Система предоставляет интерактивный GUI для загрузки видео, настройки параметров алгоритмов, визуализации результатов и экспорта отчётов.

## Особенности

- **Алгоритм Хорна-Шанка**: Плотный оптический поток с регуляризацией
- **Алгоритм Лукаса-Канаде**: Разреженный оптический поток с пирамидальным подходом
- **Интерактивный GUI**: Удобный интерфейс на PyQt5
- **Визуализация**: Различные режимы визуализации (HSV, стрелки, heat maps)
- **Оптимизация I/O**: Эффективная обработка видеофайлов с буферизацией
- **Экспорт отчётов**: Генерация JSON и HTML отчётов

## Установка

### Требования

- Python 3.8+
- OpenCV 4.5.0+
- PyQt5 5.15.0+
- NumPy 1.21.0+
- Matplotlib 3.5.0+
- SciPy 1.7.0+
+
### Установка зависимостей

```bash
pip install -r requirements.txt
```

## Использование

### Запуск приложения

```bash
python main.py
```

### Основные операции

1. **Загрузка видео**: Нажмите "Загрузить видео" и выберите файл (MP4, AVI, MOV, MKV)
2. **Навигация**: Используйте слайдер для перехода к нужному кадру
3. **Настройка параметров**: Измените параметры алгоритмов с помощью слайдеров
4. **Обработка**: Выберите алгоритм и нажмите "Обработать кадр"
5. **Визуализация**: Выберите режим визуализации из выпадающего списка
6. **Экспорт**: Сохраните результаты анализа в виде отчёта

## Алгоритмы

### Алгоритм Хорна-Шанка

**Математическая основа:**

Алгоритм решает задачу оптического потока на основе двух предположений:

1. **Brightness Constancy Constraint (BCC)**: Яркость точки не меняется при движении
   ```
   I(x, y, t) = I(x + u, y + v, t + 1)
   ```
   Линеаризация приводит к уравнению:
   ```
   I_x*u + I_y*v + I_t = 0
   ```

2. **Smoothness Constraint**: Оптический поток должен быть гладким

**Энергетический функционал:**
```
E = ∫∫[(I_x*u + I_y*v + I_t)² + λ²(‖∇u‖² + ‖∇v‖²)]dxdy
```

**Решение:**
Минимизация функционала решается итеративным методом (метод Якоби):
```
u^(n+1) = u̅^(n) - (I_x*(I_x*u̅^(n) + I_y*v̅^(n) + I_t)) / (λ² + I_x² + I_y²)
v^(n+1) = v̅^(n) - (I_y*(I_x*u̅^(n) + I_y*v̅^(n) + I_t)) / (λ² + I_x² + I_y²)
```

**Параметры:**
- `lambda` (λ): Весовой коэффициент регуляризации (0.1-10.0)
  - Меньшие значения: более точный, но менее гладкий поток
  - Большие значения: более гладкий, но менее точный поток
- `iterations`: Количество итераций (10-200)
  - Больше итераций = лучшая сходимость, но больше времени обработки

**Преимущества:**
- Плотный поток (вектор для каждого пикселя)
- Устойчивость к шуму благодаря регуляризации
- Хорошо работает для медленных движений

**Недостатки:**
- Вычислительно затратный (итеративный процесс)
- Может сглаживать резкие границы движения
- Требует тщательного подбора параметра λ

### Алгоритм Лукаса-Канаде

**Математическая основа:**

Алгоритм основан на предположении локального постоянства потока: в небольшой окрестности точки все пиксели движутся с одинаковой скоростью.

**Система уравнений:**
Для окрестности Ω размера (2k+1) x (2k+1):
```
I_x(x_i, y_i)*u + I_y(x_i, y_i)*v + I_t(x_i, y_i) = 0  для всех (x_i, y_i) ∈ Ω
```

**Решение методом наименьших квадратов:**
```
[u]   [ΣI_x²   ΣI_xI_y]⁻¹ [ΣI_xI_t]
[v] = [ΣI_xI_y ΣI_y²  ]   [ΣI_yI_t]
```

**Пирамидальный подход:**
1. Построение гауссовой пирамиды (несколько уровней с уменьшением разрешения)
2. Вычисление потока на верхнем уровне (низкое разрешение, большие перемещения)
3. Уточнение потока на следующих уровнях вниз
4. Финальное уточнение на исходном разрешении

**Параметры:**
- `window_size`: Размер окна для вычисления потока (3-31, должно быть нечётным)
  - Меньшие окна: более точные, но менее устойчивые к шуму
  - Большие окна: более устойчивые, но менее точные для небольших объектов
- `max_level`: Количество уровней пирамиды (0-4)
  - Больше уровней = возможность отслеживания больших перемещений
- `max_corners`: Максимальное количество отслеживаемых точек (100-2000)

**Преимущества:**
- Быстрое вычисление (только для ключевых точек)
- Устойчивость к шуму благодаря усреднению по окрестности
- Эффективен для структурированных текстур

**Недостатки:**
- Разреженный поток (только для "хороших" точек)
- Не работает для плоских областей
- Ограничен размером окна (без пирамиды)

## Оптимизации

### Оптимизации файловых и I/O операций

1. **Буферизация кадров:**
   - Загрузка нескольких кадров в память для уменьшения обращений к диску
   - Использование очереди для предзагрузки следующих кадров
   - Кэширование часто используемых кадров

2. **Эффективное использование OpenCV:**
   - Использование VideoCapture с оптимизированными параметрами
   - Кэширование метаданных видео (FPS, размер, количество кадров)
   - Предварительное выделение памяти для кадров

3. **Оптимизация памяти:**
   - Освобождение ресурсов при закрытии видео
   - Использование генераторов для потоковой обработки
   - Минимизация копирования данных

4. **Оптимизации вычислений:**
   - Векторизованные операции NumPy
   - Предвычисление производных и их квадратов
   - Кэширование знаменателя для ускорения итераций
   - Поддержка многоядерных вычислений через NumPy

### Оптимизации GUI

1. **Асинхронная обработка:**
   - Обработка в отдельном потоке для избежания блокировки UI
   - Прогресс-бар для отображения статуса обработки

2. **Эффективное обновление:**
   - Обновление только изменённых элементов
   - Масштабирование изображений для отображения
   - Кэширование результатов визуализации

## Структура проекта

```
optical_flow_analyzer/
├── main.py                 # Точка входа
├── requirements.txt        # Зависимости
├── README.md              # Документация
├── core/
│   ├── __init__.py
│   ├── horn_schunck.py    # Реализация Хорна-Шанка
│   ├── lucas_kanade.py    # Реализация Лукаса-Канаде
│   └── video_processor.py # Обработка видео
├── gui/
│   ├── __init__.py
│   ├── main_window.py     # Главное окно
│   └── controls.py        # Элементы управления
├── utils/
│   ├── __init__.py
│   ├── visualization.py   # Визуализация потоков
│   └── report_generator.py # Генерация отчётов
└── tests/
    ├── __init__.py
    └── test_algorithms.py # Юнит-тесты
```

## Тестирование

Запуск тестов:

```bash
python -m pytest tests/test_algorithms.py -v
```

Или:

```bash
python tests/test_algorithms.py
```

Тесты включают:
- Тест Хорна-Шанка на синтетическом паттерне
- Тест Лукаса-Канаде на последовательности с известным движением
- Тесты производительности
- Интеграционные тесты

## Визуализация

### Режимы визуализации

1. **HSV плотный поток:**
   - Hue (оттенок): направление движения (0-360°)
   - Saturation (насыщенность): величина потока
   - Value (яркость): максимальная яркость

2. **Стрелки на сетке:**
   - Векторы потока на регулярной сетке
   - Цветовое кодирование по направлению

3. **Heat map:**
   - Карта интенсивности движения
   - Цветовое кодирование величины потока

4. **Разреженный поток:**
   - Стрелки на ключевых точках
   - Цветовое кодирование по направлению и скорости

## Экспорт отчётов

Отчёты экспортируются в форматах:
- **JSON**: Структурированные данные с метаданными, параметрами и результатами
- **HTML**: Визуализированный отчёт с таблицами и изображениями

Отчёты сохраняются в директории `reports/` и включают:
- Метаданные видео
- Параметры алгоритмов
- Результаты анализа
- Метрики производительности
- Визуализации

## Рекомендации по использованию

### Выбор алгоритма

**Используйте Хорн-Шанк когда:**
- Нужен плотный поток (вектор для каждого пикселя)
- Движение медленное и плавное
- Важна гладкость результата
- Есть время на обработку

**Используйте Лукас-Канаде когда:**
- Нужен быстрый результат
- Интересуют только ключевые точки
- Движение может быть быстрым
- Нужна высокая точность для структурированных объектов

### Настройка параметров

**Хорн-Шанк:**
- Начните с `lambda = 1.0` и `iterations = 100`
- Увеличьте `lambda` для более гладкого потока
- Уменьшите `lambda` для более точного потока
- Увеличьте `iterations` для лучшей сходимости

**Лукас-Канаде:**
- Начните с `window_size = 15` и `max_level = 2`
- Увеличьте `window_size` для более устойчивого результата
- Увеличьте `max_level` для больших перемещений
- Увеличьте `max_corners` для более детального анализа

## Производительность

### Ожидаемая производительность

- **Хорн-Шанк**: Обработка кадра 640x480 за < 2 с (зависит от количества итераций)
- **Лукас-Канаде**: Обработка кадра 640x480 за < 1 с

### Оптимизация производительности

1. Уменьшите разрешение видео для быстрой обработки
2. Уменьшите количество итераций для Хорна-Шанка
3. Уменьшите количество точек для Лукаса-Канаде
4. Используйте меньшее количество уровней пирамиды

## Известные ограничения

1. **Хорн-Шанк:**
   - Медленная обработка для больших изображений
   - Может сглаживать резкие границы движения
   - Требует тщательного подбора параметров

2. **Лукас-Канаде:**
   - Работает только для структурированных текстур
   - Не работает для плоских областей
   - Ограничен размером окна

## Лицензия

Проект создан в учебных целях.

## Авторы

Разработано в рамках лабораторной работы по компьютерному зрению.

## Ссылки

- [Horn-Schunck Method](https://en.wikipedia.org/wiki/Horn%E2%80%93Schunck_method)
- [Lucas-Kanade Method](https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method)
- [OpenCV Optical Flow](https://docs.opencv.org/4.x/d4/dee/tutorial_optical_flow.html)

